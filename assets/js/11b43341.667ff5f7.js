"use strict";(self.webpackChunkgosoline_docs=self.webpackChunkgosoline_docs||[]).push([["6745"],{5293(e){e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docSidebar":[{"type":"link","href":"/docs/","label":"Overview","docId":"overview","unlisted":false},{"type":"category","label":"Fundamentals","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/fundamentals/naming-patterns","label":"Naming Patterns","docId":"fundamentals/naming-patterns","unlisted":false}],"href":"/docs/category/fundamentals"},{"type":"category","label":"Getting started","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/getting-started/create-a-consumer","label":"Create a consumer","docId":"getting-started/create-a-consumer","unlisted":false},{"type":"link","href":"/docs/getting-started/create-an-application","label":"Create an application","docId":"getting-started/create-an-application","unlisted":false},{"type":"category","label":"Testing","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/getting-started/testing/test-your-consumer","label":"Test your consumer","docId":"getting-started/testing/test-your-consumer","unlisted":false}],"href":"/docs/category/testing"}],"href":"/docs/category/getting-started"},{"type":"category","label":"How-to guides","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/how-to/configure-your-httpserver","label":"Configure your HTTP servers","docId":"how-to/configure-your-httpserver","unlisted":false},{"type":"link","href":"/docs/how-to/load-configs","label":"Load configurations","docId":"how-to/load-configs","unlisted":false},{"type":"category","label":"Logging","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/how-to/logging/use-loggers","label":"Use loggers","docId":"how-to/logging/use-loggers","unlisted":false},{"type":"link","href":"/docs/how-to/logging/sampling-and-fingers-crossed","label":"Sampling & fingers-crossed","docId":"how-to/logging/sampling-and-fingers-crossed","unlisted":false},{"type":"link","href":"/docs/how-to/logging/log-context","label":"Use context with logs","docId":"how-to/logging/log-context","unlisted":false},{"type":"link","href":"/docs/how-to/logging/implement-a-log-handler","label":"Implement a log handler","docId":"how-to/logging/implement-a-log-handler","unlisted":false}]},{"type":"category","label":"Relational databases","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/how-to/databases-sql/sqlc","label":"sqlc - SQL Client","docId":"how-to/databases-sql/sqlc","unlisted":false},{"type":"link","href":"/docs/how-to/databases-sql/sqlr","label":"sqlr - SQL Repository","docId":"how-to/databases-sql/sqlr","unlisted":false},{"type":"link","href":"/docs/how-to/databases-sql/sqlh","label":"sqlh - SQL HTTP Handlers","docId":"how-to/databases-sql/sqlh","unlisted":false}],"href":"/docs/how-to/databases-sql/"},{"type":"category","label":"Kafka","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/how-to/kafka/general","label":"Notes on general Kafka usage","docId":"how-to/kafka/general","unlisted":false},{"type":"link","href":"/docs/how-to/kafka/use-schema-registry","label":"How to use the Kafka Schema Registry","docId":"how-to/kafka/use-schema-registry","unlisted":false}]},{"type":"category","label":"Sampling","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/how-to/sampling/use-sampling","label":"Use sampling","docId":"how-to/sampling/use-sampling","unlisted":false}]},{"type":"link","href":"/docs/how-to/write-health-checks","label":"Implement health checks","docId":"how-to/write-health-checks","unlisted":false}],"href":"/docs/category/how-to-guides"},{"type":"category","label":"Reference","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/reference/naming-patterns","label":"Naming patterns","docId":"reference/naming-patterns","unlisted":false},{"type":"link","href":"/docs/reference/package-cfg","label":"Package cfg","docId":"reference/package-cfg","unlisted":false},{"type":"link","href":"/docs/reference/package-cloud_aws","label":"Package cloud/aws","docId":"reference/package-cloud_aws","unlisted":false},{"type":"link","href":"/docs/reference/package-dbx","label":"Package dbx","docId":"reference/package-dbx","unlisted":false},{"type":"link","href":"/docs/reference/package-fixtures","label":"Package fixtures","docId":"reference/package-fixtures","unlisted":false},{"type":"link","href":"/docs/reference/package-httpserver","label":"Package httpserver","docId":"reference/package-httpserver","unlisted":false},{"type":"link","href":"/docs/reference/package-log","label":"Package log","docId":"reference/package-log","unlisted":false},{"type":"link","href":"/docs/reference/package-test","label":"Package test","docId":"reference/package-test","unlisted":false}],"href":"/docs/category/reference"},{"type":"category","label":"Migrations","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/docs/migrations/app-identity-and-naming-patterns","label":"App Identity and Naming Patterns","docId":"migrations/app-identity-and-naming-patterns","unlisted":false}],"href":"/docs/category/migrations"}]},"docs":{"fundamentals/naming-patterns":{"id":"fundamentals/naming-patterns","title":"Naming Patterns","description":"Gosoline uses a unified, configuration-driven approach for naming infrastructure resources like SQS queues, SNS topics, DynamoDB tables, and more. This system ensures consistent, predictable resource names across your entire application ecosystem.","sidebar":"docSidebar"},"getting-started/create-a-consumer":{"id":"getting-started/create-a-consumer","title":"Create a consumer","description":"One of the primary use cases for gosoline is to create a message queue consumer. In this tutorial, you\'ll do just that!","sidebar":"docSidebar"},"getting-started/create-an-application":{"id":"getting-started/create-an-application","title":"Create an application","description":"For running a simple gosoline application we use the following 3 files:","sidebar":"docSidebar"},"getting-started/testing/test-your-consumer":{"id":"getting-started/testing/test-your-consumer","title":"Test your consumer","description":"In this tutorial, you\'ll create an integration test for a message queue consumer that reads from an input and writes to an output.","sidebar":"docSidebar"},"how-to/configure-your-httpserver":{"id":"how-to/configure-your-httpserver","title":"Configure your HTTP servers","description":"With gosoline, you have flexibility in how you define and run your HTTP servers. In this guide, you\'ll learn multiple ways to do this, so you can choose the option that best meet your needs.","sidebar":"docSidebar"},"how-to/databases-sql/index":{"id":"how-to/databases-sql/index","title":"Working with Relational Databases","description":"The gosoline framework provides three layered packages for working with relational databases, each building on top of the previous one:","sidebar":"docSidebar"},"how-to/databases-sql/sqlc":{"id":"how-to/databases-sql/sqlc","title":"sqlc - SQL Client","description":"The sqlc package provides a fluent API for building and executing SQL queries against relational databases. It supports MySQL and PostgreSQL, and offers connection management, query building, and transaction handling.","sidebar":"docSidebar"},"how-to/databases-sql/sqlh":{"id":"how-to/databases-sql/sqlh","title":"sqlh - SQL HTTP Handlers","description":"The sqlh package exposes database entities as REST API endpoints. Built on top of sqlr and sqlc, it provides automatic CRUD handler generation, a transformer pattern for input/output mapping, and transaction middleware for wrapping HTTP requests in database transactions.","sidebar":"docSidebar"},"how-to/databases-sql/sqlr":{"id":"how-to/databases-sql/sqlr","title":"sqlr - SQL Repository","description":"The sqlr package provides a generic, type-safe repository layer built on top of sqlc. It offers CRUD operations, relationship management, eager loading via joins and preloads, and transaction support \u2014 all using Go generics for compile-time type safety.","sidebar":"docSidebar"},"how-to/kafka/general":{"id":"how-to/kafka/general","title":"Notes on general Kafka usage","description":"In general, using Kafka with gosoline works like any other input/output type supported by the stream package.","sidebar":"docSidebar"},"how-to/kafka/use-schema-registry":{"id":"how-to/kafka/use-schema-registry","title":"How to use the Kafka Schema Registry","description":"Gosoline provides the option to use the Kafka schema registry when reading from or writing to a Kafka topic.","sidebar":"docSidebar"},"how-to/load-configs":{"id":"how-to/load-configs","title":"Load configurations","description":"There are different ways to load configurations into your application:","sidebar":"docSidebar"},"how-to/logging/implement-a-log-handler":{"id":"how-to/logging/implement-a-log-handler","title":"Implement a log handler","description":"With the cfg and log packages, you can implement a handler and make it available via config.","sidebar":"docSidebar"},"how-to/logging/log-context":{"id":"how-to/logging/log-context","title":"Use context with logs","description":"The go Context carries data from the moment the server receives an inbound request to the moment the server makes an outbound request. This means you can use it to propagate data between services and processes. With gosoline, you can use log functions to store data from the request lifecycle in the Context and attach that data to logs to provide more details.","sidebar":"docSidebar"},"how-to/logging/sampling-and-fingers-crossed":{"id":"how-to/logging/sampling-and-fingers-crossed","title":"Sampling & fingers-crossed","description":"Gosoline supports log sampling and \\"fingers-crossed\\" logging to help you manage log volume without losing critical debug information when errors occur.","sidebar":"docSidebar"},"how-to/logging/use-loggers":{"id":"how-to/logging/use-loggers","title":"Use loggers","description":"With gosoline, there are multiple ways to configure and use a logger.","sidebar":"docSidebar"},"how-to/sampling/use-sampling":{"id":"how-to/sampling/use-sampling","title":"Use sampling","description":"The smpl package helps you make a consistent sampling decision (sampled vs. not sampled) and store it in a context.Context. Other gosoline packages can then use that decision to change behavior (e.g. reduce log volume).","sidebar":"docSidebar"},"how-to/write-health-checks":{"id":"how-to/write-health-checks","title":"Implement health checks","description":"You can check the health of a running gosoline application.","sidebar":"docSidebar"},"migrations/app-identity-and-naming-patterns":{"id":"migrations/app-identity-and-naming-patterns","title":"App Identity and Naming Patterns","description":"This guide details how to migrate your gosoline application to the new Identity system and dynamic resource naming.","sidebar":"docSidebar"},"overview":{"id":"overview","title":"Overview","description":"Gosoline is a Golang-based application framework specialized for building microservices in the cloud. It provides tools for handling most of the common challenges like configuration, logging, structured code execution, handling http requests, asynchronous message processing, writing integration tests and much more.","sidebar":"docSidebar"},"reference/naming-patterns":{"id":"reference/naming-patterns","title":"Naming patterns","description":"Gosoline uses naming patterns to generate consistent names for resources (SQS queues, SNS topics, DynamoDB tables, Kafka topics, Redis keys, metric namespaces, tracing service names, ...).","sidebar":"docSidebar"},"reference/package-cfg":{"id":"reference/package-cfg","title":"Package cfg","description":"With the cfg package, you can configure and use configurations in your gosoline project.","sidebar":"docSidebar"},"reference/package-cloud_aws":{"id":"reference/package-cloud_aws","title":"Package cloud/aws","description":"The cloud/aws package","sidebar":"docSidebar"},"reference/package-dbx":{"id":"reference/package-dbx","title":"Package dbx","description":"The dbx package provides a fluent API to build SQL queries.","sidebar":"docSidebar"},"reference/package-fixtures":{"id":"reference/package-fixtures","title":"Package fixtures","description":"While using gosoline you are able to define fixtures directly in code.","sidebar":"docSidebar"},"reference/package-httpserver":{"id":"reference/package-httpserver","title":"Package httpserver","description":"Package httpserver provides a convenient way to create HTTP servers.","sidebar":"docSidebar"},"reference/package-log":{"id":"reference/package-log","title":"Package log","description":"The gosoline logger is based upon a simple interface that uses handlers internally to enable fully customizable log handling.","sidebar":"docSidebar"},"reference/package-test":{"id":"reference/package-test","title":"Package test","description":"This package acts as a wrapper over Golang\'s testing module.","sidebar":"docSidebar"}}}}')}}]);