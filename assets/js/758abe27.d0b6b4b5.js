"use strict";(self.webpackChunkgosoline_docs=self.webpackChunkgosoline_docs||[]).push([["1597"],{3786(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});var t=i(7951),a=i(4848),r=i(8453);let s={slug:"identity-and-naming-patterns",title:"Identity & Naming Patterns: Flexible, Configuration-Driven Resource Naming",authors:["jaka"],tags:["identity","naming","configuration","breaking-changes"]},l,d={authorsImageUrls:[void 0]},c=[{value:"What changed at a glance",id:"what-changed-at-a-glance",level:2},{value:"The new Identity model",id:"the-new-identity-model",level:2},{value:"Before and after",id:"before-and-after",level:3},{value:"Dynamic tags",id:"dynamic-tags",level:3},{value:"Naming patterns: define once, use everywhere",id:"naming-patterns-define-once-use-everywhere",level:2},{value:"The namespace pattern",id:"the-namespace-pattern",level:3},{value:"Concrete example: SQS queues",id:"concrete-example-sqs-queues",level:3},{value:"Strict placeholder validation",id:"strict-placeholder-validation",level:3},{value:"Full pattern reference",id:"full-pattern-reference",level:3},{value:"<code>application.Default()</code> slimmed down",id:"applicationdefault-slimmed-down",level:2},{value:"Other breaking changes",id:"other-breaking-changes",level:2},{value:"Go API",id:"go-api",level:3},{value:"Config key renames",id:"config-key-renames",level:3},{value:"ModelId refactoring",id:"modelid-refactoring",level:3},{value:"Removed packages",id:"removed-packages",level:3},{value:"Migration quick start",id:"migration-quick-start",level:2}];function o(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Managing cloud resources across multiple environments, teams, and services is hard enough without fighting your own naming conventions. Gosoline's old ",(0,a.jsx)(n.code,{children:"AppId"})," model locked you into a fixed ",(0,a.jsx)(n.code,{children:"project/family/group"})," hierarchy \u2014 useful in practice, but inflexible by design. This release replaces it with a tag-based ",(0,a.jsx)(n.code,{children:"Identity"})," system and a unified naming pattern engine that gives you full control over how every resource is named, from a single config file."]}),"\n","\n",(0,a.jsx)(n.h2,{id:"what-changed-at-a-glance",children:"What changed at a glance"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The fixed ",(0,a.jsx)(n.code,{children:"AppId"})," fields (",(0,a.jsx)(n.code,{children:"project"}),", ",(0,a.jsx)(n.code,{children:"family"}),", ",(0,a.jsx)(n.code,{children:"group"}),") are replaced by a flexible ",(0,a.jsx)(n.code,{children:"app.tags"})," map \u2014 define any keys your organization needs."]}),"\n",(0,a.jsxs)(n.li,{children:["A new ",(0,a.jsx)(n.strong,{children:"unified naming pattern engine"})," controls the names of SQS queues, SNS topics, DynamoDB tables, Kinesis streams, Kafka topics, Redis keys, CloudWatch namespaces, Prometheus prefixes, and tracing service names \u2014 all from config."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"{app.namespace}"})," lets you define your naming hierarchy once and reference it everywhere."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"application.Default()"})," has been slimmed down from ~22 options to 7, making every capability an explicit opt-in."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"pkg/es/"})," (Elasticsearch) and ",(0,a.jsx)(n.code,{children:"pkg/parquet/"})," have been removed."]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"the-new-identity-model",children:"The new Identity model"}),"\n",(0,a.jsx)(n.h3,{id:"before-and-after",children:"Before and after"}),"\n",(0,a.jsxs)(n.p,{children:["The old flat top-level config keys are replaced with a nested ",(0,a.jsx)(n.code,{children:"app:"})," block:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'# Before\nenv: production\napp_project: myproject\napp_family: platform\napp_group: core\napp_name: my-service\n\n# After\napp:\n  env: production\n  name: my-service\n  namespace: "{app.tags.project}.{app.env}.{app.tags.family}.{app.tags.group}"\n  tags:\n    project: myproject\n    family: platform\n    group: core\n'})}),"\n",(0,a.jsx)(n.p,{children:"If you set your config via environment variables, the keys change too:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"Old variable"}),(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"New variable"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:(0,a.jsx)(n.code,{children:"APP_PROJECT"})}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:(0,a.jsx)(n.code,{children:"APP_TAGS_PROJECT"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:(0,a.jsx)(n.code,{children:"APP_FAMILY"})}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:(0,a.jsx)(n.code,{children:"APP_TAGS_FAMILY"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:(0,a.jsx)(n.code,{children:"APP_GROUP"})}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:(0,a.jsx)(n.code,{children:"APP_TAGS_GROUP"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:(0,a.jsx)(n.code,{children:"APP_NAME"})}),(0,a.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,a.jsx)(n.code,{children:"APP_NAME"})," (unchanged)"]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:(0,a.jsx)(n.code,{children:"ENV"})}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:(0,a.jsx)(n.code,{children:"APP_ENV"})})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"dynamic-tags",children:"Dynamic tags"}),"\n",(0,a.jsxs)(n.p,{children:["Tags are no longer limited to ",(0,a.jsx)(n.code,{children:"project/family/group"}),". You can define any keys that make sense for your organization:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"app:\n  tags:\n    project: myproject\n    team: backend\n    region: eu-west-1\n    cost_center: engineering\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Tags are ",(0,a.jsx)(n.strong,{children:"only required if your naming patterns reference them"})," \u2014 a minimal setup with ",(0,a.jsx)(n.code,{children:"{app.env}-{queueId}"})," needs no tags at all."]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"naming-patterns-define-once-use-everywhere",children:"Naming patterns: define once, use everywhere"}),"\n",(0,a.jsxs)(n.p,{children:["Every resource gosoline manages has a configurable naming pattern. Patterns are plain strings with ",(0,a.jsx)(n.code,{children:"{placeholder}"})," macros resolved from your Identity at startup."]}),"\n",(0,a.jsx)(n.h3,{id:"the-namespace-pattern",children:"The namespace pattern"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"app.namespace"})," is the cornerstone of the new naming system. Define your hierarchy once, reference it everywhere:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'app:\n  namespace: "{app.tags.project}.{app.env}.{app.tags.family}.{app.tags.group}"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["When ",(0,a.jsx)(n.code,{children:"{app.namespace}"})," appears in a resource pattern, the dots are replaced by that service's delimiter \u2014 ",(0,a.jsx)(n.code,{children:"-"})," for most AWS services, ",(0,a.jsx)(n.code,{children:"/"})," for CloudWatch, ",(0,a.jsx)(n.code,{children:"_"})," for Prometheus. This means the same namespace definition produces correctly formatted names for every service automatically."]}),"\n",(0,a.jsx)(n.h3,{id:"concrete-example-sqs-queues",children:"Concrete example: SQS queues"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'app:\n  name: order-service\n  env: production\n  namespace: "{app.tags.project}.{app.env}.{app.tags.group}"\n  tags:\n    project: logistics\n    group: platform\n\ncloud:\n  aws:\n    sqs:\n      clients:\n        default:\n          naming:\n            queue_pattern: "{app.namespace}-{queueId}"\n            queue_delimiter: "-"\n'})}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"Queue ID in code"}),(0,a.jsx)(n.th,{style:{textAlign:"left"},children:"Resolved queue name"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:(0,a.jsx)(n.code,{children:"orders"})}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:(0,a.jsx)(n.code,{children:"logistics-production-platform-orders"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{style:{textAlign:"left"},children:(0,a.jsx)(n.code,{children:"shipments"})}),(0,a.jsx)(n.td,{style:{textAlign:"left"},children:(0,a.jsx)(n.code,{children:"logistics-production-platform-shipments"})})]})]})]}),"\n",(0,a.jsxs)(n.p,{children:["Switching to ",(0,a.jsx)(n.code,{children:"env: dev"})," automatically updates all queue names \u2014 no queue-specific config changes needed."]}),"\n",(0,a.jsx)(n.h3,{id:"strict-placeholder-validation",children:"Strict placeholder validation"}),"\n",(0,a.jsxs)(n.p,{children:["Unknown placeholders in naming patterns now return an error at startup. A typo like ",(0,a.jsx)(n.code,{children:"{app.tag.project}"})," (missing ",(0,a.jsx)(n.code,{children:"s"}),") or a leftover legacy ",(0,a.jsx)(n.code,{children:"{project}"})," is caught immediately rather than silently producing wrong resource names in production."]}),"\n",(0,a.jsx)(n.h3,{id:"full-pattern-reference",children:"Full pattern reference"}),"\n",(0,a.jsxs)(n.p,{children:["For a complete list of all configurable patterns across every service, see the ",(0,a.jsx)(n.a,{href:"/reference/naming-patterns",children:"Naming Patterns reference"})," and ",(0,a.jsx)(n.a,{href:"/fundamentals/naming-patterns",children:"Naming Patterns fundamentals"}),"."]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.h2,{id:"applicationdefault-slimmed-down",children:[(0,a.jsx)(n.code,{children:"application.Default()"})," slimmed down"]}),"\n",(0,a.jsxs)(n.p,{children:["Previously, ",(0,a.jsx)(n.code,{children:"application.Default()"})," bundled ~22 options \u2014 health checks, metrics, tracing, profiling, Sentry, task runner, producer daemon, and more \u2014 whether your application needed them or not. A simple CLI tool or a lightweight worker ended up opting out of most of them, or unknowingly carrying capabilities it didn't use."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"application.Default()"})," now ships only the essentials: config loading infrastructure and logger wiring. Everything else \u2014 health checks, metrics, tracing, profiling, stream infrastructure \u2014 is an explicit opt-in. You compose exactly the application you need:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'application.Run(\n    // load config from file\n    application.WithConfigFile("./config.dist.yml", "yml"),\n\n    // only the capabilities this service actually uses\n    application.WithHttpHealthCheck,\n    application.WithMetrics,\n    application.WithTracing,\n\n    application.WithModuleFactory("my-module", NewMyModule),\n)\n'})}),"\n",(0,a.jsx)(n.p,{children:"A service that only needs config loading and logging needs nothing beyond the new defaults. A full-featured service adds exactly the options it requires \u2014 no hidden defaults to opt out of."}),"\n",(0,a.jsxs)(n.p,{children:["This pairs naturally with the new naming system: since tags are optional and ",(0,a.jsx)(n.code,{children:"app.env"})," defaults to ",(0,a.jsx)(n.code,{children:"dev"})," and ",(0,a.jsx)(n.code,{children:"app.name"})," defaults to ",(0,a.jsx)(n.code,{children:"gosoline"}),", a minimal application needs zero configuration to start. Getting something running no longer requires wiring up a full config file first."]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"other-breaking-changes",children:"Other breaking changes"}),"\n",(0,a.jsx)(n.h3,{id:"go-api",children:"Go API"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"cfg.AppId"})," \u2192 ",(0,a.jsx)(n.code,{children:"cfg.Identity"}),"; ",(0,a.jsx)(n.code,{children:"cfg.GetAppIdFromConfig()"})," \u2192 ",(0,a.jsx)(n.code,{children:"cfg.GetAppIdentity()"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"WithLoggerGroupTag"})," \u2192 ",(0,a.jsx)(n.code,{children:'WithLoggerApplicationTag("group")'}),"; ",(0,a.jsx)(n.code,{children:"WithLoggerApplicationTag"})," \u2192 ",(0,a.jsx)(n.code,{children:"WithLoggerApplicationName"})]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"config-key-renames",children:"Config key renames"}),"\n",(0,a.jsxs)(n.p,{children:["Pattern keys have been renamed from the generic ",(0,a.jsx)(n.code,{children:"naming.pattern"})," to descriptive, service-specific names: ",(0,a.jsx)(n.code,{children:"naming.queue_pattern"}),", ",(0,a.jsx)(n.code,{children:"naming.topic_pattern"}),", ",(0,a.jsx)(n.code,{children:"naming.stream_pattern"}),", ",(0,a.jsx)(n.code,{children:"naming.table_pattern"}),", etc. Each has an accompanying ",(0,a.jsx)(n.code,{children:"naming.*_delimiter"})," setting."]}),"\n",(0,a.jsx)(n.h3,{id:"modelid-refactoring",children:"ModelId refactoring"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"mdl.ModelId"})," no longer has explicit hierarchy fields (",(0,a.jsx)(n.code,{children:".Project"}),", ",(0,a.jsx)(n.code,{children:".Family"}),", ",(0,a.jsx)(n.code,{children:".Group"}),"). Like ",(0,a.jsx)(n.code,{children:"cfg.Identity"}),", it now uses a ",(0,a.jsx)(n.code,{children:".Tags"})," map:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'// Before\nmodelId := mdl.ModelId{\n    Project: "my-project",\n    Family:  "my-family",\n    Name:    "my-model",\n}\n\n// After\nmodelId := mdl.ModelId{\n    Name: "my-model",\n    Tags: map[string]string{\n        "project": "my-project",\n        "family":  "my-family",\n    },\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The string representation of a ",(0,a.jsx)(n.code,{children:"ModelId"})," \u2014 used for message routing attributes and ",(0,a.jsx)(n.code,{children:"mdlsub"})," publishers \u2014 is now configurable via ",(0,a.jsx)(n.code,{children:"app.model_id.domain_pattern"}),". The model name is always appended automatically as the last dot-separated segment:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'app:\n  model_id:\n    domain_pattern: "{app.tags.project}.{app.env}"\n# Result: myproject.production.myModel\n'})}),"\n",(0,a.jsx)(n.p,{children:"A few things to be aware of:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"{modelId}"})," placeholder is ",(0,a.jsx)(n.strong,{children:"not"})," used in this pattern \u2014 the model name is appended automatically."]}),"\n",(0,a.jsxs)(n.li,{children:["If ",(0,a.jsx)(n.code,{children:"domain_pattern"})," is not configured, calling ",(0,a.jsx)(n.code,{children:"modelId.String()"})," will return an error."]}),"\n",(0,a.jsxs)(n.li,{children:["When parsing a canonical model ID string back, each placeholder matches non-dot characters, and the model name is everything after the final dot. This means using non-dot delimiters (e.g. ",(0,a.jsx)(n.code,{children:"{app.tags.project}-{app.env}"}),") is valid, but the last ",(0,a.jsx)(n.code,{children:"."})," in the full string always marks the boundary before the model name."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["See the ",(0,a.jsx)(n.a,{href:"/reference/naming-patterns#modelid-domain-pattern-canonical-ids",children:"Naming Patterns reference"})," for the full rules and examples."]}),"\n",(0,a.jsx)(n.h3,{id:"removed-packages",children:"Removed packages"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"pkg/es/"})})," \u2014 Elasticsearch client integration"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"pkg/parquet/"})})," \u2014 Parquet file read/write support"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"migration-quick-start",children:"Migration quick start"}),"\n",(0,a.jsxs)(n.p,{children:["For full step-by-step instructions covering stream input/output config, ",(0,a.jsx)(n.code,{children:"mdlsub"})," publishers, Go code changes, and per-service pattern updates, see the ",(0,a.jsx)(n.a,{href:"/migrations/app-identity-and-naming-patterns",children:"migration guide"}),"."]})]})}function h(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},8453(e,n,i){i.d(n,{R:()=>s,x:()=>l});var t=i(6540);let a={},r=t.createContext(a);function s(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}},7951(e){e.exports=JSON.parse('{"permalink":"/docs/blog/identity-and-naming-patterns","editUrl":"https://github.com/gosoline-project/docs/tree/main/blog/2026-02-19-identity-and-naming-patterns.md","source":"@site/blog/2026-02-19-identity-and-naming-patterns.md","title":"Identity & Naming Patterns: Flexible, Configuration-Driven Resource Naming","description":"Managing cloud resources across multiple environments, teams, and services is hard enough without fighting your own naming conventions. Gosoline\'s old AppId model locked you into a fixed project/family/group hierarchy \u2014 useful in practice, but inflexible by design. This release replaces it with a tag-based Identity system and a unified naming pattern engine that gives you full control over how every resource is named, from a single config file.","date":"2026-02-19T00:00:00.000Z","tags":[{"inline":true,"label":"identity","permalink":"/docs/blog/tags/identity"},{"inline":true,"label":"naming","permalink":"/docs/blog/tags/naming"},{"inline":true,"label":"configuration","permalink":"/docs/blog/tags/configuration"},{"inline":true,"label":"breaking-changes","permalink":"/docs/blog/tags/breaking-changes"}],"readingTime":4.93,"hasTruncateMarker":true,"authors":[{"name":"Jan Kamieth","url":"https://github.com/j4k4","imageURL":"https://avatars.githubusercontent.com/u/783502?s=400&v=4","key":"jaka","page":null}],"frontMatter":{"slug":"identity-and-naming-patterns","title":"Identity & Naming Patterns: Flexible, Configuration-Driven Resource Naming","authors":["jaka"],"tags":["identity","naming","configuration","breaking-changes"]},"unlisted":false,"nextItem":{"title":"Log Sampling in Go: Less Noise, More Debuggability","permalink":"/docs/blog/sampling-fingers-crossed-logging"}}')}}]);