---
sidebar_position: 3
title: sqlh - SQL HTTP Handlers
---

import { CodeBlock } from '../../components.jsx';
import CrudConfig from "!!raw-loader!./src/sqlh/crud/config.dist.yml";
import CrudMain from "!!raw-loader!./src/sqlh/crud/main.go";
import TxConfig from "!!raw-loader!./src/sqlh/tx/config.dist.yml";
import TxMain from "!!raw-loader!./src/sqlh/tx/main.go";
import ResultTransformerUserCrud from "!!raw-loader!./src/sqlh/result_transformer/user_crud.go";

The `sqlh` package exposes database entities as REST API endpoints. Built on top of [`sqlr`](./sqlr.mdx) and [`sqlc`](./sqlc.mdx), it provides automatic CRUD handler generation, a transformer pattern for input/output mapping, and transaction middleware for wrapping HTTP requests in database transactions.

## Getting Started

Add the dependency to your Go module:

```bash
go get github.com/gosoline-project/sqlh@v0.2.1
```

Then import the package in your Go code:

```go
import "github.com/gosoline-project/sqlh"
```

## Configuration

The `sqlh` package requires both an HTTP server and a database client. Configure them under the `httpserver` and `sqlc` keys respectively:

<CodeBlock title="config.dist.yml" language="yaml" snippet="config">{CrudConfig}</CodeBlock>

The HTTP server configuration is described in the httpserver documentation. The database configuration follows the same format described in the [sqlc documentation](./sqlc.mdx#configuration).

## CRUD Handlers

The `WithCrudHandlers` function generates a complete set of REST endpoints for an entity. It connects an `sqlr` repository with a transformer to handle input/output mapping.

### Defining Entities

Entities use the same `sqlr.Entity` base struct described in the [sqlr documentation](./sqlr.mdx#defining-entities):

<CodeBlock title="main.go" language="go" snippet="entities">{CrudMain}</CodeBlock>

### Input Types

Define separate types for create and update input. These decouple the HTTP API from the database entity:

<CodeBlock title="main.go" language="go" snippet="input output">{CrudMain}</CodeBlock>

Using separate input types lets you:
- Validate input with `binding` tags (e.g., `binding:"required"`)
- Exclude internal fields (like `Id` or `CreatedAt`) from create/update payloads

### Implementing the Transformer

The `Transformer[K, E, IC, IU]` interface converts between input types and entity types, and controls how responses are rendered. Implement `TransformCreateInput`, `TransformUpdateInput`, `RenderEntityResponse`, and `RenderQueryResponse`:

<CodeBlock title="main.go" language="go" snippet="transformer">{CrudMain}</CodeBlock>

The type parameters are:

| Parameter | Description |
|-----------|-------------|
| `K` | Primary key type (e.g., `int64`) |
| `E` | Entity type (e.g., `Author`) |
| `IC` | Create input type (e.g., `AuthorCreateInput`) |
| `IU` | Update input type (e.g., `AuthorUpdateInput`) |

The interface requires four methods:

| Method | Description |
|--------|-------------|
| `TransformCreateInput` | Converts a create input DTO into a new entity |
| `TransformUpdateInput` | Merges an update input DTO into an existing entity |
| `RenderEntityResponse` | Serialises a single entity into an `httpserver.Response` |
| `RenderQueryResponse` | Serialises a slice of entities into an `httpserver.Response` |

In the simple case above, `RenderEntityResponse` and `RenderQueryResponse` return the entity directly as JSON. See [Customizing Output Transformers](#customizing-output-transformers) for approaches when you need a separate output shape.

### Registering CRUD Handlers

Use `WithCrudHandlers` to generate all endpoints and register them with the HTTP server:

<CodeBlock title="main.go" language="go" snippet="crud handlers">{CrudMain}</CodeBlock>

The arguments are:

| Argument | Description |
|----------|-------------|
| `version` | API version number, used in the URL path (e.g., `1` produces `/v1/...`) |
| `entityName` | Singular entity name for the URL path (e.g., `"author"`) |
| `transformerFactory` | Factory that creates the transformer instance |

### Generated Endpoints

`WithCrudHandlers` registers five endpoints:

| Method | Path | Handler | Description |
|--------|------|---------|-------------|
| `POST` | `/v{n}/{entity}` | `HandleCreate` | Creates an entity from `IC` input |
| `GET` | `/v{n}/{entity}/:id` | `HandleRead` | Reads a single entity by ID |
| `PUT` | `/v{n}/{entity}/:id` | `HandleUpdate` | Updates an entity from `IU` input |
| `DELETE` | `/v{n}/{entity}/:id` | `HandleDelete` | Deletes an entity by ID; returns `204 No Content` |
| `POST` | `/v{n}/{entities}` | `HandleQuery` | Queries entities with a JSON filter |

The query endpoint uses the **plural** form of the entity name (e.g., `"author"` becomes `"/v1/authors"`). Pluralization is handled automatically.

### Query with JSON Filter

The query endpoint accepts a JSON body with a `filter` field that maps to `sqlc.JsonFilter`:

```json
{
  "filter": {
    "column": "name",
    "operator": "=",
    "value": "Alice"
  }
}
```

The filter is converted to an `sqlc.Expression` and applied as a WHERE condition on the query. See the [sqlc JSON filter documentation](./sqlc.mdx) for the full filter syntax.

### Wiring into the Application

Register handlers with the gosoline HTTP server using `router.HandleWith()`:

<CodeBlock title="main.go" language="go" snippet="main">{CrudMain}</CodeBlock>

## Customizing Output Transformers

The `Transformer` interface is the primary extension point for controlling how entities are serialised in API responses. Because it is a plain Go interface, a single implementation can be written once and reused across multiple entities — or shared as an internal library across services. This makes it straightforward to enforce consistent response shapes, pagination envelopes, or field-level access control in one place.

### JsonResultsTransformer

`JsonResultsTransformer[K, E, IC, IU]` is a simplified variant of `Transformer` for the common case where you want to map entities to a dedicated output type and return them as JSON, without needing to construct `httpserver.Response` values manually. Implement three methods — `TransformCreateInput`, `TransformUpdateInput`, and a single `TransformOutput` that converts one entity to any JSON-serialisable value — and pass the implementation to `NewJSONResultsTransformer`. The wrapping of single and multi-entity responses into JSON is handled automatically:

<CodeBlock title="user_crud.go" language="go" snippet="types">{ResultTransformerUserCrud}</CodeBlock>

<CodeBlock title="user_crud.go" language="go" snippet="transformer">{ResultTransformerUserCrud}</CodeBlock>

<CodeBlock title="user_crud.go" language="go" snippet="crud">{ResultTransformerUserCrud}</CodeBlock>

Because `TransformOutput` receives a single entity, the same function is used for both single-entity and list responses — there is no duplication. Use the full `Transformer` interface directly when you need control over HTTP status codes, headers, or non-JSON response bodies.

### Wiring Transformers

Use `sqlh.SimpleTransformer()` to wrap an already-constructed transformer into a factory when it has no startup dependencies:

```go
sqlh.SimpleTransformer[K, E, IC, IU](&MyTransformer{})
```

For transformers that require configuration or other dependencies at startup, implement `TransformerFactory` directly:

```go
type TransformerFactory[K, E, IC, IU] func(ctx context.Context, config cfg.Config, logger log.Logger) (Transformer[K, E, IC, IU], error)
```

This follows the standard gosoline factory pattern and gives the transformer access to the application config and logger during initialisation.

## Transaction Middleware

The `WithTx` function wraps a group of HTTP routes in a database transaction. Each request automatically begins a transaction before the handler runs, commits on success, and rolls back if any error occurs.

### Setting Up WithTx

Create a handler struct with a factory function, then use `WithTx` to register routes:

<CodeBlock title="main.go" language="go" snippet="with tx handler">{TxMain}</CodeBlock>

<CodeBlock title="main.go" language="go" snippet="with tx register">{TxMain}</CodeBlock>

Notice that the handler struct does not create or hold a repository. Instead of manually setting up database access, each handler receives an active `sqlc.Tx` directly through the `Bind*` helpers — the transaction is started automatically before the handler runs and committed or rolled back afterward.

`WithTx` takes two arguments:

| Argument | Description |
|----------|-------------|
| `handlerFactory` | Factory that creates the handler struct (with access to `config` and `logger`) |
| `register` | Function that registers routes on the router, receiving the handler instance |

The middleware:
1. Begins a transaction via `sqlClient.BeginTx()` before each request
2. Stores the transaction in the gin context
3. Calls the next handler
4. **Commits** if no errors occurred
5. **Rolls back** if any handler in the chain added an error to the gin context

### Transaction Binding Helpers

Inside a `WithTx`-wrapped route group, use the `BindTx` family of functions to extract the transaction and bind request input:

#### BindTx — With Input

Use `BindTx` when the handler needs both the transaction and a parsed request body:

<CodeBlock title="main.go" language="go" snippet="bind tx handler">{TxMain}</CodeBlock>

`BindTx` automatically:
- Binds the request body to the input type `I`
- Extracts the `sqlc.Tx` from the gin context
- Calls the handler with both
- Writes the response

#### BindTxN — No Input

Use `BindTxN` when the handler only needs the transaction (no request body):

<CodeBlock title="main.go" language="go" snippet="bind tx no input">{TxMain}</CodeBlock>

Since `sqlc.Tx` implements `Querier`, you can pass it to `WithClient()` on query builders to execute queries within the transaction.

#### BindTxR / BindTxNR — With Raw Request

For handlers that need access to the raw `*http.Request` (e.g., to read headers or query parameters), use the `R` variants:

```go
// With input + raw request
sqlh.BindTxR(func(cttx sqlc.Tx, req *http.Request, input *MyInput) (httpserver.Response, error) {
    userAgent := req.Header.Get("User-Agent")
    // ...
})

// No input + raw request
sqlh.BindTxNR(func(cttx sqlc.Tx, req *http.Request) (httpserver.Response, error) {
    // ...
})
```

### Wiring into the Application

<CodeBlock title="main.go" language="go" snippet="main">{TxMain}</CodeBlock>

### Summary of Binding Functions

| Function | Input | Raw Request | Signature |
|----------|-------|-------------|-----------|
| `BindTx` | Yes | No | `func(cttx sqlc.Tx, input *I) (Response, error)` |
| `BindTxR` | Yes | Yes | `func(cttx sqlc.Tx, req *http.Request, input *I) (Response, error)` |
| `BindTxN` | No | No | `func(cttx sqlc.Tx) (Response, error)` |
| `BindTxNR` | No | Yes | `func(cttx sqlc.Tx, req *http.Request) (Response, error)` |
